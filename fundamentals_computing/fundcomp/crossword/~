#include "crosswordfunc.h"

//create puzzle board
void makePuzzle(char puzzle[][MAXWORD]){
  printf("+");
  for(int i = 0; i < MAXWORD; i++){
    printf("-");
  }
  printf("+");
  printf("\n");
  for(int i = 0; i < MAXWORD; i++){
    printf("|");
    for(int j = 0; j < MAXWORD; j++){
      if((puzzle[i][j]) != '.'){
        printf(" ");
      }
      else{
        printf("#");
      }
    }
    printf("|");
    printf("\n");
  }
  printf("+");
  for(int i = 0; i < MAXWORD; i++){
    printf("-");
  }
  printf("+\n");
}

//create solution board
void makeSolution(char solution[][MAXWORD]){
  printf("+");
  for(int i = 0; i < MAXWORD; i++){
    printf("-");
  }
  printf("+");
  printf("\n");
  for(int i = 0; i < MAXWORD; i++){
    printf("|");
    for(int j = 0; j < MAXWORD; j++){
      printf("%c", solution[i][j]);
    }
    printf("|");
    printf("\n");
  }
  printf("+");
  for(int i = 0; i < MAXWORD; i++){
    printf("-");
  }
  printf("+\n");
}

void to_upper(char *word){
  for(int i = 0; i <strlen(word); i++){
    word[i] = toupper(word[i]);
    printf("%c", word[i]);
  }
  printf("\n");
}

//read in word from user for interactive mode
int getWords(WORD words[MAXWORDS]){
  printf("\nAnagram Crosword Puzzle Generator\n----------------------------------\n");
  char word[MAXWORD];
  int index = 0;
  bool too_long = false;
  printf("\nplease enter a list of words:\n");
  while(index < MAXWORDS){
    too_long = false;
    fgets(word, MAXWORD, stdin);
    if(word[strlen(word)-1] != '\n'){
      too_long = true;
      printf("sorry but this word is too long\n");
    }
    word[strlen(word)-1] = '\0';

    if(strcmp(word, ".") == 0){
      break;
    }
    
    if(strlen(word) <2){
      printf("sorry but this word is too short\n");
    }
    int allLetters = 0; 
    if(strlen(word) >= 2 && too_long == false){
      //make sure that all letters
      for(int i = 0; i <strlen(word); i++){
        if(isalpha(word[i]) == 0){
	  allLetters = 1;
	}
      }
      if(allLetters != 1){
        strcpy(words[index].word, word);
	to_upper(words[index].word);
	words[index].x = -1;
	words[index].y = -1;
	words[index].direction = true;
	words[index].used = false;
	index++;
      }
      else{
        printf("sorry but characters under than letters are in this word\n");
      }
    }
  }
  printf("\n");

  return index;
}

void lengthOrder(WORD words[MAXWORDS], int numWords){
  char temp[MAXWORD];
  for(int i = 0; i < (numWords-1); i++){
    for(int j = 0; j < (numWords-i-1); j++){
      if(strlen(words[j].word) < strlen(words[j+1].word)){
        strcpy(temp, words[j].word);
	strcpy(words[j].word, words[j+1].word);
	strcpy(words[j+1].word, temp);
        
      }
    }
  }
}

int readFile(char filename[MAXWORDS], WORD words[MAXWORDS]){
  FILE *fp = fopen(filename, "r");
  int index = 0;
  //int wordcount = 0;
 // char words[MAXWORDS][MAXWORD];
  char word[MAXWORD];
  while(1){
    bool too_long = false;
    fgets(word, MAXWORD, fp);
    if(feof(fp)) break;
    else{
     // fgets(word, MAXWORD, fp);
      if(word[strlen(word)-1] != '\n'){
        too_long = true;
        printf("%s: sorry but this word is too long\n", word);
      }
      word[strlen(word)-1] = '\0';

      if(strcmp(word, ".") == 0){
        break;
      }
    
      if(strlen(word) <2){
        printf("%s: sorry but this word is too short\n", word);
      }
    
      if(strlen(word) >= 2 && too_long == false){
        int allLetters = 0;
        //make sure that all letters
        for(int i = 0; i <strlen(word); i++){
          if(isalpha(word[i]) == 0){
	    allLetters = 1;
	  }
        }

      if(allLetters != 1){
        strcpy(words[index].word, word);
	to_upper(words[index].word);
	words[index].x = -1;
	words[index].y = -1;
	words[index].direction = true;
	words[index].used = false;
	index++;
      }

        else{
          printf("%s: sorry but characters under than letters are in this word\n", word);
        } 
      }
      //index = 0;
    }
    if(index == 20){
      break;
    }
  }

  return index;
}

void placeFirst(WORD words[MAXWORDS], char solution[MAXWORDS][MAXWORD]){
  int length = strlen(words[0].word);
  int compare = (MAXWORD - length) / 2;

  int row = 7;
  words[0].x = 7;
  words[0].y = compare;
  words[0].direction = false;
  int column = compare;
  int index = 0;
  for(int i = 0; i < length; i++){
    solution[row][column] = words[0].word[index];
    column++;
    index++;
  }
  makePuzzle(solution);
  makeSolution(solution);
}

void shuffleWords(WORD clues[MAXWORDS], int numWords, WORD words[MAXWORDS]){
  char temp[MAXWORD];
  for(int i = 0; i < numWords; i++){
    strcpy(temp, words[i].word);
    strfry(temp);
    strcpy(clues[i].word, temp);
    printf("%s\n", words[i].word);
  }
}


//displays clues function







void placeWords(WORD words[MAXWORDS], int numWords, WORD notPlaced[MAXWORDS], char solution[MAXWORDS][MAXWORD]){
 

  int noHome = 0;
  int direction = 0; //0 = vertical, 1 = horizontal, true = vertical, false = horizontal
  for(int i = 0; i < numWords-1; i++){
    int length1 = strlen(words[i].word);

    if(words[i].used == false){
      continue;
    }
    else{

      for(int j = i+1; j < numWords; j++){
        if(words[j].used == true){
	  continue;
	}
        int length2 = strlen(words[j].word);
        for(int letter = 0; letter < length1; letter++){
          char letter1 = words[i].word[letter];
          for(int index = 0; index < length2; index++){
            char letter2 = words[j].word[index];
	    if(letter1 == letter2){
	    printf("found match %s, %s, %c\n", words[i].word, words[j].word, letter2);

	    int count = 0;
	    for(int og = 0; og < length1; og++){
	      if(letter1 == words[i].word[og]){
	        break;
	      }
	      count++;
	    }
	    //result = -1;
	    int row = words[i].x;
	    int column = words[i].y;

	    int x_compare = words[i].x;
	    int y_compare = words[i].y;

	    printf("x: %d\n", x_compare);
	    printf("y: %d\n", y_compare);

	    if(words[i].direction == true){

	      x_compare += count;
	    }
	    else{
	      y_compare += count;
	    }
	    printf("x: %d\n", x_compare);
	    printf("y: %d\n", y_compare);

              //CHECKS
	  if(words[i].direction == true){
	    direction = 1;
	    if(solution[x_compare][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare+1] != '.'){
	      continue;
	    }
	  }
	  else{
	    direction = 0;
	    if(solution[x_compare+1][y_compare] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare+1] != '.'){
	      continue;
	    }
	  }

	  //place word
          if(direction == 0){

            int cOL = words[i].y + count;
	    column = column + i; //column stays constant
	    printf("index: %d\n", index);
	    int rowstart = row - index + 1 ;
	    int x = length2 - index;
	    int rowend = row + x;
	    int temp = index - 1 ;
	    int row1 = words[i].x;
	    if(rowstart-1 < 0){
	      continue;
	    }
	    if( rowend > 14){
	      continue;
	    }

            int top = length2 - index - 1;
            int counter = 0;
	    int stop = 0;
	    for(int h = top; h < rowend; h++){
	      if(solution[h][cOL] != '.'){
                if(solution[h][cOL] != words[j].word[counter]){	  
		  strcpy(notPlaced[noHome].word, words[j].word);
		  noHome++;
		  stop++;
		}
	      }
	      counter++;
	    }
	    if(stop > 0){
	      continue;
	    }

	    for(int rowplace = row1; rowplace < rowend; rowplace++){
	      printf("row: %d\n", rowplace);
              if(index == 0 ){
		solution[rowplace][cOL] = words[j].word[temp+1];
	      }
	      else{
	        solution[rowplace][cOL] = words[j].word[temp+1];
	      }
	      temp++;
	    }
	    printf("count: %d\n", count);
	    for(int j = index-1; j >= 0; j--){
	      solution[row1-1][cOL] = words[j].word[j];
	      row1--;
	    } 
	    makePuzzle(solution);
	    makeSolution(solution);

	    words[i+1].x = rowstart-1;
	    words[i+1].y = cOL;
	    words[i+1].direction = true;
	    words[i+1].used = true;

          }
	  else{
	    int rOW = words[i].x + count;
	    row = row + i -1 ; //row stays constant
	    int temp = index - 1;
	    int colstart = column - index;
	    int x = length2 - index;
	    int colend = column + x;
	    int col1 = words[i].y;
	    if(colstart < 0){
	      continue;
	    }
	    if(colend > 14){
	      continue;
	    }

            int stop = 0;
            int top = length2 - index + 1;
            int counter = 0;
	    for(int h = top; h < colend; h++){
	      if(solution[rOW][h] != '.'){
                if(solution[rOW][h] != words[i+1].word[counter]){
		  strcpy(notPlaced[noHome].word, words[i+1].word);
		  noHome++;
		  stop++;
		}
	      }
	      counter++;
	    }
	    if(stop > 0){
	      continue;
	    }


	    for(int colplace = col1; colplace < colend; colplace++){
	      if(index == 0){
	        solution[rOW][colplace] = words[i+1].word[temp+1];
	      }
	      else{
	        solution[rOW][colplace] = words[i+1].word[temp+1];
              }
	      temp++;
	    }
	    for(int j = index -1 ; j >= 0; j--){
              solution[rOW][col1-1] = words[i+1].word[j];
	      col1--;
	    }
	    makePuzzle(solution);
	    makeSolution(solution);

	    words[i+1].x = rOW;
	    words[i+1].y = colstart;
	    words[i+1].direction = false;
	    words[i+1].used = true;
	  }
	  break;
	}



      }

    }

    }

    }

    }

  }






/*




//board
void placeWords(WORD words[MAXWORDS], int numWords, WORD notPlaced[MAXWORDS], char solution[MAXWORDS][MAXWORD]){
  
  int result = 0;
  int noHome = 0;
  int direction = 0; //0 = vertical, 1 = horizontal, true = vertical, false = horizontal
  for(int i = 0; i < numWords-1; i++){
    int length1 = strlen(words[i].word);
    int length2 = strlen(words[i+1].word);
    for(int letter = 0; letter < length1; letter++){
      char letter1 = words[i].word[letter];
      //printf("letter from word1: %c\n", letter1);
      for(int index = 0; index < length2; index++){
        char letter2 = words[i+1].word[index];
	//printf("letter from word2: %c\n", letter2);
	if(words[i+1].used == true){
          continue;
	}
	if(letter1 == letter2){
	  printf("found match in %s, %s, %c\n", words[i].word, words[i+1].word, letter2);

	  int count = 0;
	  for(int og = 0; og < length1; og++){
	    if(letter1 == words[i].word[og]){
	      break;
	    }
	    count++;
	  }
	  result = -1;
	  int row = words[i].x;
	  int column = words[i].y;

	  int x_compare = words[i].x;
	  int y_compare = words[i].y;

	  printf("x: %d\n", x_compare);
	  printf("y: %d\n", y_compare);

	  if(words[i].direction == true){
	    
	    x_compare += count;
	  }
	  else{
	    y_compare += count;
	  }
	  printf("x: %d\n", x_compare);
	  printf("y: %d\n", y_compare);

	  
	  //CHECKS
	  if(words[i].direction == true){
	    direction = 1;
	    if(solution[x_compare][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare+1] != '.'){
	      continue;
	    }
	  }
	  else{
	    direction = 0;
	    if(solution[x_compare+1][y_compare] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare+1] != '.'){
	      continue;
	    }
	  }

	  //place word
          if(direction == 0){

            int cOL = words[i].y + count;
	    column = column + i; //column stays constant
	    printf("index: %d\n", index);
	    int rowstart = row - index + 1 ;
	    int x = length2 - index;
	    int rowend = row + x;
	    int temp = index - 1 ;
	    int row1 = words[i].x;
	    if(rowstart-1 < 0){
	      continue;
	    }
	    if( rowend > 14){
	      continue;
	    }

            int top = length2 - index - 1;
            int counter = 0;
	    int stop = 0;
	    for(int h = top; h < rowend; h++){
	      if(solution[h][cOL] != '.'){
                if(solution[h][cOL] != words[i+1].word[counter]){	  
		  strcpy(notPlaced[noHome].word, words[i+1].word);
		  noHome++;
		  stop++;
		}
	      }
	      counter++;
	    }
	    if(stop > 0){
	      continue;
	    }

	    for(int rowplace = row1; rowplace < rowend; rowplace++){
	      printf("row: %d\n", rowplace);
              if(index == 0 ){
		solution[rowplace][cOL] = words[i+1].word[temp+1];
	      }
	      else{
	        solution[rowplace][cOL] = words[i+1].word[temp+1];
	      }
	      temp++;
	    }
	    printf("count: %d\n", count);
	    for(int j = index-1; j >= 0; j--){
	      solution[row1-1][cOL] = words[i+1].word[j];
	      row1--;
	    } 

	    makePuzzle(solution);
	    makeSolution(solution);

	    words[i+1].x = rowstart-1;
	    words[i+1].y = cOL;
	    words[i+1].direction = true;
	    words[i+1].used = true;

          }
	  else{
	    int rOW = words[i].x + count;
	    row = row + i -1 ; //row stays constant
	    int temp = index - 1;
	    int colstart = column - index;
	    int x = length2 - index;
	    int colend = column + x;
	    int col1 = words[i].y;
	    if(colstart < 0){
	      continue;
	    }
	    if(colend > 14){
	      continue;
	    }

            int stop = 0;
            int top = length2 - index + 1;
            int counter = 0;
	    for(int h = top; h < colend; h++){
	      if(solution[rOW][h] != '.'){
                if(solution[rOW][h] != words[i+1].word[counter]){	  
		  strcpy(notPlaced[noHome].word, words[i+1].word);
		  noHome++;
		  stop++;
		}
	      }
	      counter++;
	    }
	    if(stop > 0){
	      continue;
	    }


	    for(int colplace = col1; colplace < colend; colplace++){
	      if(index == 0){
	        solution[rOW][colplace] = words[i+1].word[temp+1];
	      }
	      else{
	        solution[rOW][colplace] = words[i+1].word[temp+1];
              }
	      temp++;
	    }
	    for(int j = index -1 ; j >= 0; j--){
              solution[rOW][col1-1] = words[i+1].word[j];
	      col1--;
	    }
	    makePuzzle(solution);
	    makeSolution(solution);

	    words[i+1].x = rOW;
	    words[i+1].y = colstart;
	    words[i+1].direction = false;
	    words[i+1].used = true;

	  }
	  break;
	}
	else{
	  result++;
	}
      }

    }
    result = 0;
  }
}
*/

/*
void runThru(WORD notPlaced[MAXWORDS], char solution[MAXWORDS][MAXWORD]){
  

  for(int i = 0; i < MAXWORDS; i++){
    goBack(notPlaced[i].word, solution);
  }

}

void goBack(char word[MAXWORD], char solution[MAXWORDS][MAXWORD]){
  int length = strlen(word);
  int direction = 0; // 0 = vertical, 1 = horizontal;
  for(int index = 0; index < length; index++){

    for(int row = 0; row < MAXWORD; row++){
      for(int col = 0; col < MAXWORD; col++){
        
	if(solution[row][col] == word[index]){
          if(solution[row+1][col] != '.'){
	    direction = 1;
	    if(solution[row][col+1] != '.'){
	      continue;
	    }
	    if(solution[row][col-1] != '.'){
	      continue;
	    }
	    if(solution[row+1][col+1] != '.'){
	      continue;
	    }
	    if(solution[row-1][col-1] != '.'){
	      continue;
	    }
	    if(solution[row+1][col-1] != '.'){
	      continue;
	    }
	    if(solution[row-1][col+1] != '.'){
	      continue;
	    }

	  }
	  else{
	    direction = 0;
	    if(solution[row+1][col] != '.'){
	      continue;
	    }
	    if(solution[row-1][col] != '.'){
	      continue;
	    }
	    if(solution[row+1][col+1] != '.'){
	      continue;
	    }
	    if(solution[row-1][col-1] != '.'){
	      continue;
	    }
	    if(solution[row+1][col-1] != '.'){
	      continue;
	    }
	    if(solution[row-1][col+1] != '.'){
	      continue;
	    }

	  }
	  if(direction == 0){
            int top = length - index - 1;
            int counter = 0;
            int stop = 0;
	    for(int h = top; h < rowend; h++){
	      if(solution[h][cOL] != '.'){
                if(solution[h][cOL] != words[i+1].word[counter]){	  
		  strcpy(notPlaced[noHome].word, words[i+1].word);
		  noHome++;
		  stop++;
                }
	      }
	      counter++;
	    }
	    if(stop > 0){
	      continue;
	    }

            int cOL = words[i].y + count;
	    column = column + i; //column stays constant
	  //printf("index: %d\n", index);
	    int rowstart = row - index + 1 ;
	    int x = length2 - index;
	    int rowend = row + x;
	    int temp = index - 1 ;
	    int row1 = words[i].x;
	    if(rowstart-1 < 0){
	      continue;
	    }
	    if( rowend > 14){
	      continue;
	    }

	    for(int rowplace = row1; rowplace < rowend; rowplace++){
	      printf("row: %d\n", rowplace);
              if(index == 0 ){
                solution[rowplace][cOL] = words[i+1].word[temp+1];
	      }
	      else{
	        solution[rowplace][cOL] = words[i+1].word[temp+1];
	      }
	      temp++;
	    }
	    printf("count: %d\n", count);
	    for(int j = index-1; j >= 0; j--){
	      solution[row1-1][cOL] = words[i+1].word[j];
	      row1--;
	    }

            makePuzzle(solution);
	    makeSolution(solution);
	  }
	  else{
	    //row = row - 1;
	    int rOW = words[i].x + count;
	    row = row + i -1 ; //row stays constant
	    int temp = index - 1;
	    int colstart = column - index;
	    int x = length - index;
	    int colend = column + x;
	    int col1 = words[i].y;
	    if(colstart < 0){
	      continue;
	    }
	    if(colend > 14){
	      continue;
	    }

            int stop = 0;
            int top = length2 - index + 1;
            int counter = 0;
	    for(int h = top; h < colend; h++){
	      if(solution[rOW][h] != '.'){
                if(solution[rOW][h] != words[i+1].word[counter]){	  
		  strcpy(notPlaced[noHome].word, words[i+1].word);
		  noHome++;
		  stop++;
		}
	      }
	      counter++;
	    }
	    if(stop > 0){
	      continue;
	    }

	    for(int colplace = col1; colplace < colend; colplace++){
	      if(index == 0){
	        solution[rOW][colplace] = words[i+1].word[temp+1];
	      }
	      else{
	        solution[rOW][colplace] = words[i+1].word[temp+1];
              }
	      temp++;
	    }
	    for(int j = index -1 ; j >= 0; j--){
              solution[rOW][col1-1] = words[i+1].word[j];
	      col1--;
	    }
	    makePuzzle(solution);

      }
    }

  }

}
*/
void fileMakePuzzle(char puzzle[][MAXWORD], FILE *fp){
  
  fputs("+",fp);
  for(int i = 0; i < MAXWORD; i++){
    fputs("-",fp);
  }
  fputs("+",fp);
  fputs("\n", fp);
  for(int i = 0; i < MAXWORD; i++){
    fputs("|", fp);
    for(int j = 0; j < MAXWORD; j++){
      if((puzzle[i][j]) != '.'){
        fputs(" ", fp);
      }
      else{
        fputs("#", fp);
      }
    }
    fputs("|", fp);
    fputs("\n", fp);
  }
  fputs("+", fp);
  for(int i = 0; i < MAXWORD; i++){
    fputs("-", fp);
  }
  fputs("+\n", fp);  

}

void fileMakeSolution(char solution[][MAXWORD], FILE *fp){

  fputs("+", fp);
  for(int i = 0; i < MAXWORD; i++){
    fputs("-",fp);
  }
  fputs("+",fp);
  fputs("\n", fp);
  for(int i = 0; i < MAXWORD; i++){
    fputs("|",fp);
    for(int j = 0; j < MAXWORD; j++){
      //fputs( solution[i][j], fp);
      fprintf(fp, "%c", solution[i][j]);
    }
    fputs("|",fp);
    fputs("\n",fp);
  }
  fputs("+", fp);
  for(int i = 0; i < MAXWORD; i++){
    fputs("-", fp);
  }
  fputs("+\n", fp);
}

void placeFirstFile(WORD words[MAXWORDS], char solution[MAXWORDS][MAXWORD], FILE *fp){
  int length = strlen(words[0].word);
  int compare = (MAXWORD - length) / 2;

  int row = 7;
  words[0].x = 7;
  words[0].y = compare;
  words[0].direction = false;
  int column = compare;
  int index = 0;
  for(int i = 0; i < length; i++){
    solution[row][column] = words[0].word[index];
    column++;
    index++;
  }
}

void shuffleWordsFile(WORD clues[MAXWORDS], int numWords, WORD words[MAXWORDS], FILE *fp){
  char temp[MAXWORD];
  for(int i = 0; i < numWords; i++){
    strcpy(temp, words[i].word);
    strfry(temp);
    strcpy(clues[i].word, temp);
    fputs(words[i].word, fp);
  }
}

void placeWordsFile(WORD words[MAXWORDS], int numWords, WORD notPlaced[MAXWORDS], char solution[MAXWORDS][MAXWORD], FILE *fp){
  int result = 0;
  int direction = 0; //0 = vertical, 1 = horizontal, true = vertical, false = horizontal
  for(int i = 0; i < numWords-1; i++){
    int length1 = strlen(words[i].word);
    int length2 = strlen(words[i+1].word);
    for(int letter = 0; letter < length1; letter++){
      char letter1 = words[i].word[letter];
      //printf("letter from word1: %c\n", letter1);
      for(int index = 0; index < length2; index++){
        char letter2 = words[i+1].word[index];
	//printf("letter from word2: %c\n", letter2);
	if(words[i+1].used == true){
          continue;
	}
	if(letter1 == letter2){
	  //printf("found match in %s, %s, %c\n", words[i].word, words[i+1].word, letter2);

	  int count = 0;
	  for(int og = 0; og < length1; og++){
	    if(letter1 == words[i].word[og]){
	      break;
	    }
	    count++;
	  }
	  result = -1;
	  int row = words[i].x;
	  int column = words[i].y;

	  int x_compare = words[i].x;
	  int y_compare = words[i].y;

	  //printf("x: %d\n", x_compare);
	  //printf("y: %d\n", y_compare);

	  if(words[i].direction == true){
	    
	    x_compare += count;
	  }
	  else{
	    y_compare += count;
	  }
	  //printf("x: %d\n", x_compare);
	  //printf("y: %d\n", y_compare);

	  
	  //CHECKS
	  if(words[i].direction == true){
	    direction = 1;
	    if(solution[x_compare][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare+1] != '.'){
	      continue;
	    }
	  }

	  else{
	    direction = 0;
	    if(solution[x_compare+1][y_compare] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare+1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare+1][y_compare-1] != '.'){
	      continue;
	    }
	    if(solution[x_compare-1][y_compare+1] != '.'){
	      continue;
	    }
	  }

	  //place word
          if(direction == 0){

            int cOL = words[i].y + count;
	    column = column + i; //column stays constant
	    //printf("index: %d\n", index);
	    int rowstart = row - index + 1 ;
	    int x = length2 - index;
	    int rowend = row + x;
	    int temp = index - 1 ;
	    int row1 = words[i].x;
	    if(rowstart-1 < 0){
	      continue;
	    }
	    if( rowend > 14){
	      continue;
	    }
	    for(int rowplace = row1; rowplace < rowend; rowplace++){
	      //printf("row: %d\n", rowplace);
              if(index == 0 ){
                solution[rowplace][cOL] = words[i+1].word[temp+1];
	      }
	      else{
	        solution[rowplace][cOL] = words[i+1].word[temp+1];
	      }
	      temp++;
	    }
	    //printf("count: %d\n", count);
	    //if (count != 0){
	      for(int j = index-1; j >= 0; j--){
	        solution[row1-1][cOL] = words[i+1].word[j];
	        row1--;
	      }  
	    //}

	   // fileMakePuzzle(solution, fp);
	    //fileMakeSolution(solution, fp);

	    words[i+1].x = rowstart-1;
	    words[i+1].y = cOL;
	    words[i+1].direction = true;
	    words[i+1].used = true;

          }

	  else{
	    //row = row - 1;
	    int rOW = words[i].x + count;
	    row = row + i -1 ; //row stays constant
	    int temp = index - 1;
	    int colstart = column - index;
	    int x = length2 - index;
	    int colend = column + x;
	    int col1 = words[i].y;
	    if(colstart < 0){
	      continue;
	    }
	    if(colend > 14){
	      continue;
	    }
	    for(int colplace = col1; colplace < colend; colplace++){
	      if(index == 0){
	        solution[rOW][colplace] = words[i+1].word[temp+1];
	      }
	      else{
	        solution[rOW][colplace] = words[i+1].word[temp+1];
              }
	      temp++;
	    }
	    for(int j = index -1 ; j >= 0; j--){
              solution[rOW][col1-1] = words[i+1].word[j];
	      col1--;
	    }
	    //fileMakePuzzle(solution, fp);
	    //fileMakeSolution(solution, fp);

	    words[i+1].x = rOW;
	    words[i+1].y = colstart;
	    words[i+1].direction = false;
	    words[i+1].used = true;

	  }
	  break;
	}
	else{
	  result++;
	}
      }

    }
    result = 0;
  }
}
 


void toFile(WORD words[MAXWORDS], WORD clues[MAXWORDS], WORD notPlaced[MAXWORDS], char solution[MAXWORDS][MAXWORD], char filename2[MAXWORD], char filename1[MAXWORD]){

  FILE *fp;
  fp = fopen(filename2, "w");

  int numWords = readFile(filename1, words);

  lengthOrder(words, numWords);

  placeFirstFile(words, solution, fp);

  shuffleWordsFile(clues, numWords, words, fp);

  placeWordsFile(words, numWords, notPlaced, solution, fp); 

  fileMakePuzzle(solution, fp);
  fileMakeSolution(solution, fp);


}
